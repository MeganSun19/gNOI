# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc
import warnings

from github.com.openconfig.gnoi.os import os_pb2 as github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2

GRPC_GENERATED_VERSION = '1.67.1'
GRPC_VERSION = grpc.__version__
_version_not_supported = False

try:
    from grpc._utilities import first_version_is_lower
    _version_not_supported = first_version_is_lower(GRPC_VERSION, GRPC_GENERATED_VERSION)
except ImportError:
    _version_not_supported = True

if _version_not_supported:
    raise RuntimeError(
        f'The grpc package installed is at version {GRPC_VERSION},'
        + f' but the generated code in github.com/openconfig/gnoi/os/os_pb2_grpc.py depends on'
        + f' grpcio>={GRPC_GENERATED_VERSION}.'
        + f' Please upgrade your grpc module to grpcio>={GRPC_GENERATED_VERSION}'
        + f' or downgrade your generated code using grpcio-tools<={GRPC_VERSION}.'
    )


class OSStub(object):
    """The OS service provides an interface for OS installation on a Target. The
    Client progresses through 3 RPCs:
    1) Installation - provide the Target with the OS package.
    2) Activation - activate an installed OS package.
    3) Verification - verify that the Activation was successful.

    Dual Supervisor Target is supported, where the above process is executed once
    for the whole Target or once for each Supervisor. Targets that require the 
    above process executed once per Supervisor will reply with the flag
    Verify->VerifyResponse->individual_supervisor_install set to true.

    Note that certain platforms may have particular approaches to upgrade the
    firmware of specific components, eg., power supply units, etc.. In addition,
    platforms may have processes to apply patches to the running OS. Handling
    these exceptions introduces extra complexities. For Targets that implement
    this service, component firmware upgrade or OS patching MUST be embedded
    within an OS upgrade.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.Install = channel.stream_stream(
                '/gnoi.os.OS/Install',
                request_serializer=github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.InstallRequest.SerializeToString,
                response_deserializer=github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.InstallResponse.FromString,
                _registered_method=True)
        self.Activate = channel.unary_unary(
                '/gnoi.os.OS/Activate',
                request_serializer=github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.ActivateRequest.SerializeToString,
                response_deserializer=github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.ActivateResponse.FromString,
                _registered_method=True)
        self.Verify = channel.unary_unary(
                '/gnoi.os.OS/Verify',
                request_serializer=github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.VerifyRequest.SerializeToString,
                response_deserializer=github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.VerifyResponse.FromString,
                _registered_method=True)


class OSServicer(object):
    """The OS service provides an interface for OS installation on a Target. The
    Client progresses through 3 RPCs:
    1) Installation - provide the Target with the OS package.
    2) Activation - activate an installed OS package.
    3) Verification - verify that the Activation was successful.

    Dual Supervisor Target is supported, where the above process is executed once
    for the whole Target or once for each Supervisor. Targets that require the 
    above process executed once per Supervisor will reply with the flag
    Verify->VerifyResponse->individual_supervisor_install set to true.

    Note that certain platforms may have particular approaches to upgrade the
    firmware of specific components, eg., power supply units, etc.. In addition,
    platforms may have processes to apply patches to the running OS. Handling
    these exceptions introduces extra complexities. For Targets that implement
    this service, component firmware upgrade or OS patching MUST be embedded
    within an OS upgrade.
    """

    def Install(self, request_iterator, context):
        """Install transfers an OS package into the Target. No concurrent Install RPCs
        MUST be allowed to the same Target.

        The OS package file format is platform dependent. The platform MUST
        validate that the OS package that is supplied is valid and bootable. This
        SHOULD include a hash check against a known good hash. It is recommended
        that the hash is embedded in the OS package.

        The Target manages its own persistent storage, and OS installation process.
        It stores a set of distinct OS packages, and always proactively frees up
        space for incoming new OS packages. It is guaranteed that the Target always
        has enough space for a valid incoming OS package. The currently running OS
        packages MUST never be removed. The Client MUST expect that the last
        successfully installed package is available.

        The Install RPC allows the Client to specify the OS package version. If
        the Target already has an OS package with the same version then there is no
        need to transfer the OS package to the Target. If the Target does not have
        an OS package with the same version, then the OS package is copied.

        Scenario 1 - When the Target already has the OS package:

        Client :--------------|--------------> Target
        TransferRequest --> 
        <-- [Validated|InstallError]


        Scenario 2 - When the Target does not have the OS package:

        Client :--------------|--------------> Target
        TransferRequest -->
        <-- [TransferReady|InstallError]
        transfer_content  -->
        ...
        <-- [TransferProgress|InstallError]
        ...
        TransferEnd -->
        <-- [Validated|InstallError]

        On a dual Supervisor Target which requires installing the entire 
        system with one Install RPC, one Install RPC is sufficient to 
        install the package on all Supervisors.
        On a dual Supervisor Target which requires one Install RPC per 
        supervisor, the Install RPC applies to the Active Supervisor unless 
        InstallRequest->TransferRequest->standby_supervisor is set, in which 
        case it applies to the Standby Supervisor. The Target MUST accept any 
        order of package installation.
        On a dual Supervisor Target which requires installing the entire 
        system with one Install RPC, the package MUST be made available on 
        all Supervisors or none. If upon installation the package is absent 
        from either Supervisor, the Target will transfer to both Supervisors 
        overwriting the existing one.
        On a dual Supervisor Target which requires one Install RPC per 
        supervisor, the Target MUST always attempt to copy the OS package 
        between Supervisors first before accepting the transfer from the 
        Client. The syncing progress is reported to the client with 
        InstallResponse->SyncProgress messages.

        If a switchover is triggered during the Install RPC, the RPC MUST
        immediately abort with Error->type->UNEXPECTED_SWITCHOVER.

        Scenario 3 - When both Supervisors already have the OS package, regardless
        of the value in Start.standby_supervisor:

        Client :--------------|--------------> Target
        TransferRequest -->
        <-- [Validated|InstallError]


        Scenario 4 - On a dual Supervisor Target which requires one Install RPC
        per supervisor, and when one of the Supervisors already has the OS 
        package but the other Supervisor is the target of the Install:

        Client :--------------|--------------> Target
        TransferRequest -->
        <-- [SyncProgress|InstallError]
        ...
        <-- [Validated|InstallError]


        Scenario 5 - When neither of the two Supervisors has the OS package:

        Client :--------------|--------------> Target
        TransferRequest -->
        <-- [TransferReady|InstallError]
        transfer_content  -->
        ...
        <-- [TransferProgress|InstallError]
        ...
        TransferEnd -->
        <-- [Validated|InstallError]

        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Activate(self, request, context):
        """Activate sets the requested OS version as the version which is used at the
        next reboot, and reboots the Target if the 'no_reboot' flag is not set.
        When booting the requested OS version fails, the Target recovers by
        booting the previously running OS package.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def Verify(self, request, context):
        """Verify checks the running OS version. During reboot, gRPC client returns
        the gRPC status code UNAVAILABLE while the Target is unreachable, which
        should be retried by the client until successful. After the Target becomes
        reachable, it should report all ready or error states normally through
        VerifyResponse.

        On a dual Supervisor system, if the Standby Supervisor is rebooting, it
        should be reported in the VerifyResponse via verify_standby as
        StandbyState UNAVAILABLE.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_OSServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'Install': grpc.stream_stream_rpc_method_handler(
                    servicer.Install,
                    request_deserializer=github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.InstallRequest.FromString,
                    response_serializer=github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.InstallResponse.SerializeToString,
            ),
            'Activate': grpc.unary_unary_rpc_method_handler(
                    servicer.Activate,
                    request_deserializer=github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.ActivateRequest.FromString,
                    response_serializer=github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.ActivateResponse.SerializeToString,
            ),
            'Verify': grpc.unary_unary_rpc_method_handler(
                    servicer.Verify,
                    request_deserializer=github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.VerifyRequest.FromString,
                    response_serializer=github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.VerifyResponse.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'gnoi.os.OS', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('gnoi.os.OS', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class OS(object):
    """The OS service provides an interface for OS installation on a Target. The
    Client progresses through 3 RPCs:
    1) Installation - provide the Target with the OS package.
    2) Activation - activate an installed OS package.
    3) Verification - verify that the Activation was successful.

    Dual Supervisor Target is supported, where the above process is executed once
    for the whole Target or once for each Supervisor. Targets that require the 
    above process executed once per Supervisor will reply with the flag
    Verify->VerifyResponse->individual_supervisor_install set to true.

    Note that certain platforms may have particular approaches to upgrade the
    firmware of specific components, eg., power supply units, etc.. In addition,
    platforms may have processes to apply patches to the running OS. Handling
    these exceptions introduces extra complexities. For Targets that implement
    this service, component firmware upgrade or OS patching MUST be embedded
    within an OS upgrade.
    """

    @staticmethod
    def Install(request_iterator,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.stream_stream(
            request_iterator,
            target,
            '/gnoi.os.OS/Install',
            github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.InstallRequest.SerializeToString,
            github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.InstallResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Activate(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/gnoi.os.OS/Activate',
            github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.ActivateRequest.SerializeToString,
            github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.ActivateResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def Verify(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/gnoi.os.OS/Verify',
            github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.VerifyRequest.SerializeToString,
            github_dot_com_dot_openconfig_dot_gnoi_dot_os_dot_os__pb2.VerifyResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
